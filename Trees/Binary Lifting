struct BinaryLifting {
  int n, exp = 20;
  vector<int> depth;
  vector<vector<int>> T;
  BinaryLifting(const vector<vector<int>> &adj) {
    n = adj.size();
    T = vector<vector<int>>(n, vector<int>(exp));
    depth.resize(n);
    auto dfs = [&](auto &&self, int u, int p, int d) -> void {
      T[u][0] = p;
      depth[u] = d++;
      for (int v : adj[u]) {
        if (v != p) {
          self(self, v, u, d);
        }
      }
    };
    dfs(dfs, 0, -1, 0);
    for (int i = 1; i < exp; ++i) {
      for (int u = 0; u < n; ++u) {
        if (~T[u][i - 1]) {
          T[u][i] = T[T[u][i - 1]][i - 1];
        }
      }
    }
  }
 
  int lca(int u, int v) {
    if (depth[u] < depth[v]) {
      swap(u, v);
    }
    int dif = depth[u] - depth[v];
    for (int i = 0; i < exp; ++i) {
      if (dif >> i & 1) {
        u = T[u][i];
      }
    }
    if (u == v) {
      return u;
    }
    for (int i = exp - 1; ~i; --i) {
      if (T[u][i] != T[v][i]) {
        u = T[u][i];
        v = T[v][i];
      }
    }
    return T[u][0];
  }
 
  int distance(int u, int v) {
    return depth[u] + depth[v] - 2 * depth[lca(u, v)];
  }
 
  int distance(int u, int v, int l) {
    return depth[u] + depth[v] - 2 * depth[l];
  }
 
  int jump(int u, int d) {
    for (int i = 0; i < exp; ++i) {
      if (d >> i & 1) {
        u = T[u][i];
      }
    }
    return u;
  }
 
  int getNodePath(int a, int b, int dis) {
    int l = lca(a, b);
    int d = distance(a, l, l);
    if (d >= dis) {
      return jump(a, dis);
    }
    d = distance(a, b, l);
    return jump(b, d - dis);
  };
};
