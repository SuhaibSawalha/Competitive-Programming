void XorConvolution(vector<int64_t> &a, vector<int64_t> &b, vector<int64_t> &c) {
  int m = (int) a.size();
  c.resize(m);
  if (m == 1) {
    c[0] = a[0] * b[0];
    return;
  }
  vector<int64_t> ap, bp, an, bn;
  for (int i = 0; i < m / 2; i++) {
    ap.push_back(a[i] + a[i + m / 2]);
    bp.push_back(b[i] + b[i + m / 2]);
    an.push_back(a[i] - a[i + m / 2]);
    bn.push_back(b[i] - b[i + m / 2]);
  }
  vector<int64_t> d0, d1;
  XorConvolution(ap, bp, d0);
  XorConvolution(an, bn, d1);
  for (int i = 0; i < m / 2; i++) {
    c[i] = (d0[i] + d1[i]) / 2;
    c[i + m / 2] = (d0[i] - d1[i]) / 2;
  }
}

// cnt2[0] -= n, cnt[i] /= 2
// cnt3[a[i]] -= n - 1, cnt3[i] /= 3
